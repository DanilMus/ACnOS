#include <iostream>
#include <string>
using namespace std;

int main()
// Шаблон программы с вставкой кода на Ассемблере
{
	setlocale(LC_ALL, "Russian");
	// Описание переменных, инициализация, ввод исходных данных...:
	static int A, B, C; // Для заданий I и II
	static int M1[5]; // Для задания II
	static int M2[2][3]; // Для задания III


// Задание I-1: C = A + B
// Для выполнения операций одно из чисел необходимо переслать в регистр,
// так как в системе команд Intel нет соманд в формате "память-память".
// Использование регистра-аккумулятора в вычислениях позволяет оптимизировать команды.
	cout << "Введите числа А и В > ";
	cin >> A;
	cin >> B;
	// Код для решения задачи на Ассемблере:
	__asm
	{
		MOV EAX, A
		ADD EAX, B
		MOV C, EAX
	}
	// Вывод результатов:
	cout << "Результат (C = A + B): ";
	cout << C << endl;
	cout << endl;
	system("pause");


// Задание I-2:
    // Ввод A и B с клавиатуры
    std::cout << "Введите число A: ";
    std::cin >> A;
    std::cout << "Введите число B: ";
    std::cin >> B;

    // Вычисление разности A и B с использованием инлайн-ассемблера
    __asm {
        mov eax, A   ; Загрузка A в регистр eax
        sub eax, B   ; Вычитание B из eax
        mov C, eax   ; Сохранение результата в C
    }

    // Вывод результата C на экран
    std::cout << "Разность A и B: " << C << std::endl;

    return 0;

// Задание I-3: C = min(A, B)
// Для выполнения операций одно из чисел необходимо переслать в регистр,
// так как в системе команд Intel нет соманд в формате "память-память".
// Использование регистра-аккумулятора в вычислениях позволяет оптимизировать команды.
	cout << "Введите числа А и В > ";
	cin >> A;
	cin >> B;
	// Код для решения задачи на Ассемблере:
	__asm
	{
		MOV EAX, A
		CMP EAX, B ; сравнение A и B - "неразрушающее вычитание"
		JLE Skip   ; пропуск пересылки, если A<=B - минимум уже содержится в EAX
		MOV EAX, B ; пересылка B в регистр в качестве минимума (при сравнении оказалось, что A>B)
	Skip:	MOV C, EAX ; сохраняем результат после сравнения в переменной C		
	}
	// Вывод результатов:
	cout << "Результат C = min(A, B): ";
	cout << C << endl;
	cout << endl;
	system("pause");

// Задание I-4:
    int MinMaxDiff;

    // Ввод A и B с клавиатуры
    std::cout << "Введите число A: ";
    std::cin >> A;
    std::cout << "Введите число B: ";
    std::cin >> B;

    // Вычисление разницы между минимумом и максимумом (A и B) с использованием инлайн-ассемблера
    __asm {
        mov eax, A   ; Загрузка A в регистр eax
        cmp eax, B   ; Сравнение A и B
        jl is_min    ; Если A < B, переход к is_min
        jmp is_max   ; В противном случае переход к is_max

    is_min:
        mov MinMaxDiff, eax   ; A - минимум
        sub MinMaxDiff, B    ; Вычисление разницы
        jmp done

    is_max:
        mov MinMaxDiff, B    ; B - минимум
        sub MinMaxDiff, A    ; Вычисление разницы

    done:
    }

// Вывод результата MinMaxDiff на экран
std::cout << "Разница между минимумом и максимумом: " << MinMaxDiff << std::endl;


// Задание II-1: C = SUM(M1[0], M1[1], M1[2], M1[3], M1[4])
// Для вычисления суммы необходимо организовать цикл по всем элементам (от 0 до 4)
	cout << "Введите числа - 5 элементов массива > ";
	cin >> M1[0];
	cin >> M1[1];
	cin >> M1[2];
	cin >> M1[3];
	cin >> M1[4];
	// Код для решения задачи на Ассемблере:
	// Вариант 1 - режим адресации, где смещение (эффективный адрес) вычмсляется как 
	// ЭА = Disp (отклонение M1) + Index (в регистре ESI) * Scale:
	__asm
	{
		XOR EAX, EAX ; Обнуление регистра-аккумулятора - в нём будет накапливаться сумма
		MOV ECX, 5 ; Значение счётчика цикла равно количеству элементов массива
		MOV ESI, 0 ; Индекс для первого элемента массива
	CYCLE1:        ; Начало цикла суммирования элементов массива
		  ADD EAX, M1[ESI*4] ; Добавление значения элемента массива с номером ESI в сумму.
				    ; Масштаб равен 4 - в массиве числа в формате двойного слова, занимают по 4 байта.
		  INC ESI 	; Переход к следующему элементу - увеличение индекса
		LOOP CYCLE1
		MOV C, EAX		
	}
	// Вывод результатов:
	cout << "Результат вычисления C = SUM(M1[0], M1[1], M1[2], M1[3], M1[4]): ";
	cout << C << endl;
	cout << endl;
	system("pause");
	// Вариант 2 - режим адресации, где смещение (эффективный адрес) вычмсляется как 
	// ЭА = Base (база массива в регистре EBX) + Index (в регистре ESI) * Scale:
	__asm
	{
		XOR EAX, EAX; Обнуление регистра-аккумулятора - в нём будет накапливаться сумма
		MOV ECX, 5; Значение счётчика цикла равно количеству элементов массива
		LEA EBX, M1; Пересылка смещения начала массива в регистр базы
				  ; Другой вариант определения базы для данного варианта: 
				  ; MOV EBX, offset M1
		MOV ESI, 0; Индекс для первого элемента массива
	CYCLE2:		  ; Начало цикла суммирования элементов массива
		  ADD EAX, [EBX][ESI * 4]; Добавление значения элемента массива с номером ESI в сумму.
					; Масштаб равен 4 - в массиве числа в формате двойного слова, занимают по 4 байта.
		  INC ESI; Переход к следующему элементу - увеличение индекса
		LOOP CYCLE2
		MOV C, EAX; Сохранение суммы в переменной
	}
	// Вывод результатов:
	cout << "Результат вычисления C = SUM(M1[1], M1[5], M1[2], M1[3], M1[4]): ";
	cout << C << endl;
	cout << endl;
	system("pause");


    // Задание II-2-5:
    int n; // Размер массива
    std::cout << "Введите размер массива: ";
    std::cin >> n;

    int A[n];
    // Введите элементы массива
    for (int i = 0; i < n; ++i) {
        std::cout << "Введите элемент " << i + 1 << ": ";
        std::cin >> A[i];
    }

    int minElement = A[0];
    int minIndex = 0;
    int maxElement = A[0];
    int maxIndex = 0;
    int maxCount = 0;

    // Ассемблерные вставки
    __asm {
        mov ecx, n
        mov esi, 0
        mov edi, 0
        mov ebx, 0

        // Инициализация минимального и максимального элементов
        mov eax, A[esi]
        mov minElement, eax
        mov maxElement, eax

        // Вычисление минимального элемента и его индекса
        loop_start:
        cmp eax, minElement
        jge not_less_min
        mov minElement, eax
        mov minIndex, esi
        not_less_min:

        // Вычисление максимального элемента и его индекса
        cmp eax, maxElement
        jle not_greater_max
        mov maxElement, eax
        mov maxIndex, esi
        not_greater_max:

        // Вычисление количества максимальных элементов
        cmp eax, maxElement
        jne not_equal_max
        inc ebx
        not_equal_max:

        inc esi
        loop loop_start
        mov maxCount, ebx
    }

    cout << "Минимальный элемент: " << minElement << " (позиция: " << minIndex << ")" << endl;
    cout << "Максимальный элемент: " << maxElement << " (последняя позиция: " << maxIndex << ")" << endl;
    cout << "Количество максимальных элементов: " << maxCount << endl;
    cout << "Разница между минимальным и максимальным элементами: " << maxElement - minElement << endl;


	// Задание III-1: C = SUM(M2[0,0], M2[0,1],M2[0,2],M2[1,0],M2[1,1],M2[1,2])
	// Для вычисления суммы необходимо организовать циклы по всем строкам и столбцам
	cout << "Введите числа - 6 элементов массива по строкам 2*3 > ";
	cin >> M2[0][0];
	cin >> M2[0][1];
	cin >> M2[0][2];
	cin >> M2[1][0];
	cin >> M2[1][1];
	cin >> M2[1][2];
	// Код для решения задачи на Ассемблере:
	__asm
	{
		XOR EAX, EAX; Обнуление регистра - аккумулятора - в нём будет накапливаться сумма
		XOR EBX, EBX; Обнуление регистра базы для вычисления адреса первой строки массива
		MOV ECX, 2; Значение счётчика цикла по строкам
		CR : ; Цикл по строкам
				MOV ESI, 0; Индекс для первого элемента в строке
				PUSH ECX; Сохранение счётчика цикла по строкам в стеке
				MOV ECX, 3; Значение счётчика цикла по столбцам в строке - в регистр-счётчик
			CC : ; Начало цикла по столбцам - суммирования элементов массива по строке
					ADD EAX, M2[EBX][ESI * 4]; Добавление значения элемента массива в сумму
									; Масштаб равен 4 - в массиве числа в формате двойного слова, занимают по 4 байта.
					INC ESI; Переход к следующему элементу в строке - увеличение индекса
				LOOP CC ; Цикл по столбцам в строке 
				POP ECX ; Восстановление счётчика строк для внешнего цикла
				ADD EBX, 3*4; Переход к следующей строке - увеличение базы на длину строки
		LOOP CR ; Цикл по строкам  
		MOV C, EAX ; Сохранение суммы в переменной
	}
	// Вывод результатов:
	cout << "Результат вычисления C = SUM(M2[0,0], M2[0,1],M2[0,2],M2[1,0],M2[1,1],M2[1,2]): ";
	cout << C << endl;
	cout << endl;
	system("pause");

    // Задание III-2-4:
    int m;
    cout << "Введите размерность массива A (m и n): ";
    cin >> m >> n;

    int A[m][n];
    int C[m];
    int minElement = A[0][0];
    int minRow = 0;
    int minColumn = 0;

    // Введите элементы массива A
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            cout << "Введите элемент A[" << i << "][" << j << "]: ";
            cin >> A[i][j];
        }
    }

    // Ассемблерные вставки для задачи 2 - вычисление сумм элементов по строкам
    __asm {
        mov esi, 0
    row_loop:
        xor eax, eax  // Обнуляем сумму для каждой строки
        mov ecx, n
        mov edi, 0
    col_loop:
        add eax, A[esi][edi]
        inc edi
        loop col_loop
        mov C[esi * 4], eax
        inc esi
        cmp esi, m
        jl row_loop
    }

    // Ассемблерные вставки для задачи 3 - нахождение максимального элемента и его позиции
    __asm {
        mov esi, 0
        mov minElement, A[0][0]
        mov minRow, 0
        mov minColumn, 0
    row_loop_max:
        mov ecx, n
        mov edi, 0
    col_loop_max:
        mov eax, A[esi][edi]
        cmp eax, minElement
        jge not_less_min
        mov minElement, eax
        mov minRow, esi
        mov minColumn, edi
        not_less_min:
        inc edi
        loop col_loop_max
        inc esi
        cmp esi, m
        jl row_loop_max
    }

    // Ассемблерные вставки для задачи 4 - вычисление минимальных элементов по столбцам
    __asm {
        mov esi, 0
    col_loop_min:
        xor eax, eax  // Обнуляем минимум для каждого столбца
        mov ecx, m
        mov edi, 0
    row_loop_min:
        mov ebx, A[edi][esi]
        cmp ebx, eax
        jge not_less_min_col
        mov eax, ebx
        not_less_min_col:
        inc edi
        loop row_loop_min
        mov C[esi * 4], eax
        inc esi
        cmp esi, n
        jl col_loop_min
    }

    // Вывод результатов
    cout << "Массив C (суммы элементов по строкам):" << endl;
    for (int i = 0; i < m; ++i) {
        cout << "C[" << i << "] = " << C[i] << endl;
    }
    cout << "Максимальный элемент в массиве A: " << minElement << endl;
    cout << "Позиция первого элемента: [" << minRow << "][" << minColumn << "]" << endl;

    cout << "Массив C (минимальные элементы по столбцам):" << endl;
    for (int i = 0; i < n; ++i) {
        cout << "C[" << i << "] = " << C[i] << endl;
    }

    return 0;
}